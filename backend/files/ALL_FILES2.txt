
C:\Users\J KENNETSHEELA\quiz-app\backend\routes>(
echo =====================================  
 echo FILE NAME: authRoutes.js  
 echo =====================================  
 type "authRoutes.js"  
 echo.
) 
=====================================
FILE NAME: authRoutes.js
=====================================
const express = require("express");
const router = express.Router();
const admin = require("firebase-admin");
const User = require("../models/User");

// Middleware to verify Firebase token
const verifyToken = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split("Bearer ")[1];
    
    if (!token) {
      return res.status(401).json({ error: "No token provided" });
    }

    const decodedToken = await admin.auth().verifyIdToken(token);
    req.user = decodedToken;
    next();
  } catch (error) {
    console.error("Token verification error:", error);
    res.status(401).json({ error: "Invalid or expired token" });
  }
};

// Create or update user profile
router.post("/profile", verifyToken, async (req, res) => {
  try {
    const { username, department, college, city } = req.body;
    const { uid, email, picture, firebase } = req.user;

    if (!username || !department || !college || !city) {
      return res.status(400).json({ error: "All fields are required" });
    }

    // Determine provider
    let provider = "email";
    if (firebase.sign_in_provider === "google.com") provider = "google";
    if (firebase.sign_in_provider === "github.com") provider = "github";

    const user = await User.findOneAndUpdate(
      { firebaseUid: uid },
      {
        firebaseUid: uid,
        email,
        username,
        department,
        college,
        city,
        photoURL: picture || null,
        provider,
        lastLogin: new Date()
      },
      { 
        upsert: true, 
        new: true,
        runValidators: true
      }
    );

    res.json({ 
      message: "Profile saved successfully", 
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        department: user.department,
        college: user.college,
        city: user.city,
        photoURL: user.photoURL
      }
    });
  } catch (error) {
    console.error("Profile creation error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get user profile
router.get("/profile", verifyToken, async (req, res) => {
  try {
    const user = await User.findOne({ firebaseUid: req.user.uid });
    
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json({
      id: user._id,
      username: user.username,
      email: user.email,
      department: user.department,
      college: user.college,
      city: user.city,
      photoURL: user.photoURL,
      provider: user.provider,
      createdAt: user.createdAt
    });
  } catch (error) {
    console.error("Get profile error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Update last login
router.post("/login", verifyToken, async (req, res) => {
  try {
    await User.findOneAndUpdate(
      { firebaseUid: req.user.uid },
      { lastLogin: new Date() }
    );
    res.json({ message: "Login recorded" });
  } catch (error) {
    console.error("Login record error:", error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
module.exports.verifyToken = verifyToken;

C:\Users\J KENNETSHEELA\quiz-app\backend\routes>(
echo =====================================  
 echo FILE NAME: eventRoutes.js  
 echo =====================================  
 type "eventRoutes.js"  
 echo.
) 
=====================================
FILE NAME: eventRoutes.js
=====================================
const express = require("express");
const router = express.Router();
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const { verifyToken } = require("./authRoutes");
const EventService = require("../services/eventService");
const Event = require("../models/Event");
const EventParticipant = require("../models/EventParticipant");

// Ensure uploads directory exists
const uploadsDir = path.join(__dirname, "../uploads");
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

// Multer configuration
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = /pdf|docx|doc/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (extname && mimetype) {
      return cb(null, true);
    }
    cb(new Error("Only PDF and DOCX files are allowed"));
  }
});

// Create event (admin only)
router.post("/create", verifyToken, upload.array("setFiles"), async (req, res) => {
  try {
    const event = await EventService.createEvent(req.body, req.files, req.user.uid);
    res.status(201).json({
      message: "Event created successfully",
      eventId: event._id
    });
  } catch (error) {
    console.error("Create event error:", error);
    // Clean up uploaded files on error
    if (req.files) {
      req.files.forEach(file => {
        fs.unlink(file.path, err => {
          if (err) console.error("Error deleting file:", err);
        });
      });
    }
    res.status(500).json({ error: error.message });
  }
});

// Get all events
router.get("/", async (req, res) => {
  try {
    const events = await Event.find()
      .select("-adminPassword -studentPassword")
      .sort({ createdAt: -1 });
    
    res.json({ events });
  } catch (error) {
    console.error("Get events error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get specific event details
router.get("/:eventId", async (req, res) => {
  try {
    const event = await Event.findById(req.params.eventId)
      .select("-adminPassword -studentPassword");
    
    if (!event) {
      return res.status(404).json({ error: "Event not found" });
    }

    res.json({ event });
  } catch (error) {
    console.error("Get event error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Student login to event
router.post("/student-login", verifyToken, async (req, res) => {
  try {
    const { eventId, rollNo, department, password } = req.body;

    const participant = await EventService.studentLogin({
      eventId,
      userId: req.user.uid,
      rollNo,
      department,
      password
    });

    res.json({ 
      message: "Login successful", 
      participantId: participant._id 
    });
  } catch (error) {
    console.error("Student login error:", error);
    res.status(400).json({ error: error.message });
  }
});

// Get active set for an event
router.get("/:eventId/active-set", async (req, res) => {
  try {
    const event = await Event.findById(req.params.eventId);
    
    if (!event) {
      return res.status(404).json({ error: "Event not found" });
    }

    const activeSet = event.sets.find(set => set.isActive);
    
    if (!activeSet) {
      return res.json({ message: "No active set", activeSet: null });
    }

    res.json({ activeSet });
  } catch (error) {
    console.error("Get active set error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Start set (student)
router.post("/start-set", verifyToken, async (req, res) => {
  try {
    const { participantId, setId } = req.body;

    const result = await EventService.startSet(participantId, setId, req.user.uid);

    res.json(result);
  } catch (error) {
    console.error("Start set error:", error);
    res.status(400).json({ error: error.message });
  }
});

// Submit set (student)
router.post("/submit-set", verifyToken, async (req, res) => {
  try {
    const { participantId, setId, score, answers } = req.body;

    const result = await EventService.submitSet({
      participantId,
      setId,
      userId: req.user.uid,
      score,
      answers
    });

    res.json({ 
      message: "Set submitted successfully",
      result
    });
  } catch (error) {
    console.error("Submit set error:", error);
    res.status(400).json({ error: error.message });
  }
});

// Toggle set active status (admin)
router.post("/toggle-set", verifyToken, async (req, res) => {
  try {
    const { eventId, setId, adminPassword, enable } = req.body;

    await EventService.toggleSet({
      eventId,
      setId,
      adminPassword,
      enable,
      userId: req.user.uid
    });

    res.json({ 
      message: enable ? "Set enabled" : "Set disabled" 
    });
  } catch (error) {
    console.error("Toggle set error:", error);
    res.status(400).json({ error: error.message });
  }
});

// Get participants list (admin)
router.get("/:eventId/participants", verifyToken, async (req, res) => {
  try {
    const participants = await EventParticipant.find({ 
      eventId: req.params.eventId 
    }).populate("userId", "username email department");

    res.json({ participants });
  } catch (error) {
    console.error("Get participants error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get event statistics (admin)
router.get("/:eventId/stats", verifyToken, async (req, res) => {
  try {
    const stats = await EventService.getEventStats(req.params.eventId);
    res.json({ stats });
  } catch (error) {
    console.error("Get stats error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Delete event (admin)
router.delete("/:eventId", verifyToken, async (req, res) => {
  try {
    const { adminPassword } = req.body;

    await EventService.deleteEvent(
      req.params.eventId,
      adminPassword,
      req.user.uid
    );

    res.json({ message: "Event deleted successfully" });
  } catch (error) {
    console.error("Delete event error:", error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

C:\Users\J KENNETSHEELA\quiz-app\backend\routes>(
echo =====================================  
 echo FILE NAME: practiceRoutes.js  
 echo =====================================  
 type "practiceRoutes.js"  
 echo.
) 
=====================================
FILE NAME: practiceRoutes.js
=====================================
const express = require("express");
const router = express.Router();
const { verifyToken } = require("./authRoutes");
const PracticeService = require("../services/practiceService");
const PracticeSet = require("../models/PracticeSet");
const QuestionBank = require("../models/QuestionBank");

// Get all available practice sets with lock status
router.get("/sets", verifyToken, async (req, res) => {
  try {
    const { category, topic, level } = req.query;
    
    if (!category || !topic || !level) {
      return res.status(400).json({ error: "Category, topic, and level are required" });
    }

    const sets = await PracticeService.getSetsWithLock(
      req.user.uid,
      category,
      topic,
      level
    );

    res.json({ sets });
  } catch (error) {
    console.error("Get sets error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get questions for a specific set
router.get("/sets/:setId/questions", verifyToken, async (req, res) => {
  try {
    const set = await PracticeSet.findById(req.params.setId)
      .populate("questions");

    if (!set) {
      return res.status(404).json({ error: "Set not found" });
    }

    // Remove correct answers from questions
    const questions = set.questions.map(q => ({
      _id: q._id,
      question: q.question,
      options: q.options,
      category: q.category,
      topic: q.topic,
      level: q.level
    }));

    res.json({
      setNumber: set.setNumber,
      timeLimit: set.timeLimit,
      questions
    });
  } catch (error) {
    console.error("Get questions error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Start a practice set
router.post("/sets/start", verifyToken, async (req, res) => {
  try {
    const { category, topic, level, setNumber } = req.body;

    if (!category || !topic || !level || !setNumber) {
      return res.status(400).json({ error: "All fields are required" });
    }

    const progress = await PracticeService.startSet({
      userId: req.user.uid,
      category,
      topic,
      level,
      setNumber
    });

    res.json({ 
      message: "Set started successfully",
      progress: {
        id: progress._id,
        startedAt: progress.startedAt,
        timeLimit: progress.timeLimit
      }
    });
  } catch (error) {
    console.error("Start set error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Submit a practice set
router.post("/sets/submit", verifyToken, async (req, res) => {
  try {
    const { category, topic, level, setNumber, answers } = req.body;

    if (!category || !topic || !level || !setNumber || !answers) {
      return res.status(400).json({ error: "All fields are required" });
    }

    const result = await PracticeService.submitSet({
      userId: req.user.uid,
      category,
      topic,
      level,
      setNumber,
      answers
    });

    res.json({
      message: "Set submitted successfully",
      score: result.score,
      totalQuestions: result.totalQuestions,
      results: result.results,
      completedAt: result.completedAt
    });
  } catch (error) {
    console.error("Submit set error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get user's progress history
router.get("/progress", verifyToken, async (req, res) => {
  try {
    const progress = await PracticeService.getUserProgress(req.user.uid);
    res.json({ progress });
  } catch (error) {
    console.error("Get progress error:", error);
    res.status(500).json({ error: error.message });
  }
});
// Add to practiceRoutes.js
router.get("/categories/:category/topics", async (req, res) => {
  const topics = await QuestionBank.distinct("topic", { 
    category: req.params.category 
  });
  res.json({ topics });
});

router.get("/topics/:topic/levels", async (req, res) => {
  const { category } = req.query;
  const levels = await QuestionBank.distinct("level", { 
    category, 
    topic: req.params.topic 
  });
  res.json({ levels });
});

// Get available categories and topics
router.get("/categories", async (req, res) => {
  try {
    const categories = await QuestionBank.distinct("category");
    const result = [];

    for (const category of categories) {
      const topics = await QuestionBank.distinct("topic", { category });
      result.push({ category, topics });
    }

    res.json({ categories: result });
  } catch (error) {
    console.error("Get categories error:", error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

C:\Users\J KENNETSHEELA\quiz-app\backend\routes>(
echo =====================================  
 echo FILE NAME: userRoutes.js  
 echo =====================================  
 type "userRoutes.js"  
 echo.
) 
=====================================
FILE NAME: userRoutes.js
=====================================
const express = require("express");
const router = express.Router();
const { body, validationResult } = require("express-validator");
const { verifyFirebaseToken } = require("../config/firebase");
const User = require("../models/User");

// Middleware to check validation errors
const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};

// Create/Update user profile
router.post(
  "/profile",
  verifyFirebaseToken,
  [
    body("username").trim().notEmpty().withMessage("Username is required"),
    body("department").isIn(["AIDS", "CS", "IT", "Mechanical", "Civil", "ECE", "EEE"]),
    body("college").trim().notEmpty(),
    body("city").trim().notEmpty()
  ],
  validate,
  async (req, res) => {
    try {
      const { username, department, college, city, rollNo } = req.body;

      let user = await User.findOne({ firebaseUid: req.user.uid });

      if (user) {
        // Update existing user
        user.username = username;
        user.department = department;
        user.college = college;
        user.city = city;
        if (rollNo) user.rollNo = rollNo;
        await user.save();
      } else {
        // Create new user
        user = await User.create({
          firebaseUid: req.user.uid,
          email: req.user.email,
          username,
          department,
          college,
          city,
          rollNo
        });
      }

      res.json({ 
        message: "Profile saved successfully",
        user: {
          id: user._id,
          username: user.username,
          email: user.email,
          department: user.department,
          xp: user.xp,
          level: user.level,
          streak: user.streak
        }
      });
    } catch (error) {
      console.error("Profile save error:", error);
      res.status(500).json({ error: "Failed to save profile" });
    }
  }
);

// Get user profile
router.get("/profile", verifyFirebaseToken, async (req, res) => {
  try {
    const user = await User.findOne({ firebaseUid: req.user.uid })
      .populate("friends", "username email xp level")
      .populate("studyGroups");

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json({ user });
  } catch (error) {
    console.error("Get profile error:", error);
    res.status(500).json({ error: "Failed to fetch profile" });
  }
});

// Get leaderboard
router.get("/leaderboard", verifyFirebaseToken, async (req, res) => {
  try {
    const { scope = "global", department } = req.query;
    
    let query = {};
    if (scope === "department" && department) {
      query.department = department;
    }

    const users = await User.find(query)
      .sort({ xp: -1, level: -1 })
      .limit(100)
      .select("username department college xp level streak");

    res.json({ leaderboard: users });
  } catch (error) {
    console.error("Leaderboard error:", error);
    res.status(500).json({ error: "Failed to fetch leaderboard" });
  }
});

// Add friend
router.post("/friends/:userId", verifyFirebaseToken, async (req, res) => {
  try {
    const user = await User.findOne({ firebaseUid: req.user.uid });
    const friendId = req.params.userId;

    if (user.friends.includes(friendId)) {
      return res.status(400).json({ error: "Already friends" });
    }

    user.friends.push(friendId);
    await user.save();

    // Also add to friend's list
    await User.findByIdAndUpdate(friendId, {
      $addToSet: { friends: user._id }
    });

    res.json({ message: "Friend added successfully" });
  } catch (error) {
    console.error("Add friend error:", error);
    res.status(500).json({ error: "Failed to add friend" });
  }
});

// Update preferences
router.patch("/preferences", verifyFirebaseToken, async (req, res) => {
  try {
    const { theme, notifications } = req.body;
    
    const user = await User.findOne({ firebaseUid: req.user.uid });
    
    if (theme) user.preferences.theme = theme;
    if (typeof notifications === "boolean") {
      user.preferences.notifications = notifications;
    }
    
    await user.save();
    res.json({ message: "Preferences updated", preferences: user.preferences });
  } catch (error) {
    console.error("Update preferences error:", error);
    res.status(500).json({ error: "Failed to update preferences" });
  }
});

module.exports = router;
